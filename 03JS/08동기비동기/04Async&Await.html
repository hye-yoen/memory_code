<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .box {
            width: 1280px;
            height: 800px;
            border: 1px solid;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
        }

        .box>.main-thread {
            width: 300px;
            border: 1px solid;
            height: 100%;
        }

        .box>.sub1-thread {
            width: 300px;
            border: 1px solid;
            height: 100%;
        }

        .box>.sub2-thread {
            width: 300px;
            border: 1px solid;
            height: 100%;
        }
    </style>
</head>

<body>
    <div class="box">
        <div class="main-thread"></div>
        <div class="sub1-thread"></div>
        <div class="sub2-thread"></div>
    </div>

    <script>
        const mainThreadEl = document.querySelector('.main-thread');
        const sub1ThreadEl = document.querySelector('.sub1-thread');
        const sub2ThreadEl = document.querySelector('.sub2-thread');

        // Promise 비동기 객체 확인한기
        // new Promise((resolve,reject)=>{    // resolve: 성공,reject:실패
        //     setTimeout(()=>{
        //         const success = true;
        //         if(success){
        //             resolve("요청성공 : 서버로부터 데이터 수신완료");
        //         }else{
        //             reject("요청실패 : 서버오류(500)");
        //         }
        //     },3000);
        // })
        // .then((response)=>{ //정상처리시 후속처리
        //     console.log(response)
        // })
        // .catch(()=>{ //오류발생시 후속처리
        //     console.log(error)          
        // })

        //메인스레드 생성(왼쪽 블럭 반복처리)
        let cnt = 0;
        setInterval(() => {
            mainThreadEl.innerHTML += `MAIN THREAD...${++cnt}<br/>`;
        }, 1000)

        // 비동기 기본 함수
        function sub_process_executor(val) {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    resolve(val);
                }, 3000)
            });
        }

        //Async / Await 사용없이 비동기 처리 진행 // 비동기 처리 시간? 제어
        // sub_process_executor(11)
        //     .then((response) => { //정상처리시 후속처리
        //         console.log('sub..',response);
        //         sub1ThreadEl.innerHTML=`sub1...${response}`
        //     })
        //     .catch(() => { //오류발생시 후속처리
        //         console.log(error)
        //     })
        // sub_process_executor(22)
        //     .then((response) => { //정상처리시 후속처리
        //         console.log(response);
        //         sub2ThreadEl.innerHTML=`sub2...${response}`
        //     })
        //     .catch(() => { //오류발생시 후속처리
        //         console.log(error)
        //     })


        //Async / Await 를 이용한 비동기 처리 순서 배치 //비동기 처리 순서 제어
        async function sub_process_order(){
            await sub_process_executor(11).then((response) => { 
                console.log('sub..',response);
                sub1ThreadEl.innerHTML=`sub1...${response}`;
            })
            .catch(() => {console.log(error)})
            await sub_process_executor(22).then((response) => { 
                console.log(response);
                sub2ThreadEl.innerHTML=`sub2...${response}`;
            })
            .catch(() => { console.log(error)})
        }
        sub_process_order();

    </script>
</body>

</html>